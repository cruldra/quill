---
title: 设计 Delta 格式
---

富文本编辑器缺乏表达其自身内容的规范。直到最近,大多数富文本编辑器甚至不知道自己的编辑区域中有什么内容。这些编辑器只是将 HTML 传递给用户,同时也将解析和解释的负担一并传递。在任何给定时间,这种解释都会与主流浏览器供应商的解释有所不同,从而导致用户获得不同的编辑体验。

Quill 是第一个真正理解自己内容的富文本编辑器。其关键在于 Deltas,这是描述富文本的规范。Deltas 设计得易于理解和使用。我们将介绍 Deltas 背后的一些思考,以阐明*为什么*事情是这样的。

如果你正在寻找关于 Deltas *是什么*的参考,那么 [Delta 文档](/docs/delta/)是一个更简洁的资源。


## 纯文本

让我们从基础开始,只处理纯文本。已经有一种无处不在的格式来存储纯文本:字符串。现在,如果我们想在此基础上构建并描述格式化文本,例如当某个范围是粗体时,我们需要添加额外的信息。

数组是唯一可用的其他有序数据类型,因此我们使用对象数组。这也使我们能够利用 JSON 与各种工具兼容。

```javascript
const content = [
  { text: 'Hello' },
  { text: 'World', bold: true }
];
```

如果需要,我们可以将斜体、下划线和其他格式添加到主对象中;但将 `text` 与所有这些分开会更清晰,因此我们将格式组织在一个字段下,我们将其命名为 `attributes`。

```javascript
const content = [
  { text: 'Hello' },
  { text: 'World', attributes: { bold: true } }
];
```


### 紧凑性

即使使用我们目前简单的 Delta 格式,它也是不可预测的,因为上面的 "Hello World" 示例可以用不同的方式表示,所以我们无法预测将生成哪一种:

```javascript
const content = [
  { text: 'Hel' },
  { text: 'lo' },
  { text: 'World', attributes: { bold: true } }
];
```

为了解决这个问题,我们添加了 Deltas 必须紧凑的约束。有了这个约束,上面的表示就不是有效的 Delta,因为它可以用前面的示例更紧凑地表示,其中 "Hel" 和 "lo" 没有分开。同样,我们不能有 `{ bold: false, italic: true, underline: null }`,因为 `{ italic: true }` 更紧凑。


### 规范性

我们没有为 `bold` 分配任何含义,只是它描述了文本的某种格式。我们完全可以使用不同的名称,例如 `weighted` 或 `strong`,或使用不同范围的可能值,例如数字或描述性的权重范围。可以在 CSS 中找到一个例子,其中大多数这些歧义都在起作用。如果我们在页面上看到粗体文本,我们无法预测其规则集是 `font-weight: bold` 还是 `font-weight: 700`。这使得解析 CSS 以辨别其含义的任务变得更加复杂。

我们不定义可能的属性集及其含义,但我们确实添加了一个额外的约束,即 Deltas 必须是规范的。如果两个 Deltas 相等,它们表示的内容必须相等,并且不能有两个不相等的 Deltas 表示相同的内容。从编程角度来说,这允许你简单地深度比较两个 Deltas 以确定它们表示的内容是否相等。

因此,如果我们有以下内容,我们唯一可以得出的结论是 `a` 与 `b` 不同,但不知道 `a` 或 `b` 的含义。

```javascript
const content = [{
  text: "Mystery",
  attributes: {
    a: true,
    b: true
  }
}];
```

由实现者选择适当的名称:

```javascript
const content = [{
  text: "Mystery",
  attributes: {
    italic: true,
    bold: true
  }
}];
```

这种规范化适用于键和值、`text` 和 `attributes`。例如,Quill 默认情况下:

- 使用六字符十六进制值表示颜色,而不是 RGB
- 只有一种方式表示换行符,即 `\n`,而不是 `\r` 或 `\r\n`
- <code>text: "Hello&nbsp;&nbsp;World"</code> 明确表示 "Hello" 和 "World" 之间恰好有两个空格

其中一些选择可以由用户自定义,但 Deltas 中的规范约束规定选择必须是唯一的。

这种明确的可预测性使 Deltas 更易于使用,既因为你需要处理的情况更少,也因为相应的 Delta 看起来不会有意外。从长远来看,这使得使用 Deltas 的应用程序更易于理解和维护。


## 行格式

行格式会影响整行的内容,因此它们对我们的紧凑性和规范性约束提出了有趣的挑战。表示居中文本的一种看似合理的方式如下:

```javascript
const content = [
  { text: "Hello", attributes: { align: "center" } },
  { text: "\nWorld" }
];
```

但是,如果用户删除换行符会怎样?如果我们只是天真地删除换行符,Delta 现在看起来会像这样:

```javascript
const content = [
  { text: "Hello", attributes: { align: "center" } },
  { text: "World" }
];
```

这一行还居中吗?如果答案是否定的,那么我们的表示就不紧凑,因为我们不需要属性对象,可以合并两个字符串:

```javascript
const content = [
  { text: "HelloWorld" }
];
```

但如果答案是肯定的,那么我们就违反了规范约束,因为具有 align 属性的字符的任何排列都将表示相同的内容。

因此,我们不能只是天真地删除换行符。我们还必须删除行属性,或将它们扩展以填充行上的所有字符。

如果我们从以下内容中删除换行符会怎样?

```javascript
const content = [
  { text: "Hello", attributes: { align: "center" } },
  { text: "\n" },
  { text: "World", attributes: { align: "right" } }
];
```

不清楚我们得到的行是居中对齐还是右对齐。我们可以删除两者,或者有一些排序规则来偏向其中一个,但我们的 Delta 在这条路上变得更加复杂和难以使用。

这个问题需要原子性,我们在*换行符*本身中找到了这一点。但我们有一个差一错误,即如果我们有 *n* 行,我们只有 *n-1* 个换行符。

为了解决这个问题,Quill 为所有文档"添加"一个换行符,并始终以 "\n" 结束 Deltas。

```javascript
// Hello World 在两行上
const content = [
  { text: "Hello" },
  { text: "\n", attributes: { align: "center" } },
  { text: "World" },
  { text: "\n", attributes: { align: "right" } }   // Deltas 必须以换行符结束
];
```


## 嵌入内容

我们想要添加嵌入内容,如图像或视频。字符串自然用于文本,但我们对嵌入内容有更多选择。由于有不同类型的嵌入内容,我们的选择只需要包含此类型信息,然后是实际内容。这里有许多合理的选项,但我们将使用一个对象,其唯一键是嵌入类型,值是内容表示,可以具有任何类型或值。

```javascript
const img = {
  image: {
    url: 'https://quilljs.com/logo.png'
  }
};

const f = {
  formula: 'e=mc^2'
};
```

与文本类似,图像可能具有一些定义特征和一些临时特征。我们对文本内容使用了 `attributes`,也可以对图像使用相同的 `attributes` 字段。但正因为如此,我们可以保持一直使用的通用结构,但应该将 `text` 键重命名为更通用的名称。出于我们稍后将探讨的原因,我们将选择名称 `insert`。将所有这些放在一起,我们有:

```javascript
const content = [{
  insert: 'Hello'
}, {
  insert: 'World',
  attributes: { bold: true }
}, {
  insert: {
    image: 'https://exclamation.com/mark.png'
  },
  attributes: { width: '100' }
}];
```


## 描述变更

正如 Delta 这个名字所暗示的,我们的格式可以描述对文档的更改,以及文档本身。事实上,我们可以将文档视为我们对空文档所做的更改,以获得我们正在描述的文档。正如你可能已经猜到的,使用 Deltas 来描述更改也是我们之前将 `text` 重命名为 `insert` 的原因。我们将 Delta 数组中的每个元素称为操作(Operation)。

#### 删除

要描述删除文本,我们需要知道在哪里删除以及删除多少个字符。要删除嵌入内容,不需要任何特殊处理,只需要了解嵌入内容的长度。如果它不是一,那么我们需要指定当只删除嵌入内容的一部分时会发生什么。目前没有这样的规范,因此无论图像有多少像素、视频有多少分钟长,或幻灯片中有多少张幻灯片;嵌入内容的长度都是**一**。

描述删除的一种合理方式是显式存储其索引和长度。

```javascript
const delta = [{
  delete: {
    index: 4,
    length: 1
  }
}, {
  delete: {
    index: 12,
    length: 3
  }
}];
```

我们必须根据索引对删除进行排序,并确保没有范围重叠,否则我们的规范约束将被违反。这种索引和长度方法还有其他一些缺点,但在描述格式更改后更容易理解。

#### 插入

现在 Deltas 可能描述对非空文档的更改,`{ insert: "Hello" }` 是不够的,因为我们不知道 "Hello" 应该插入到哪里。我们可以通过添加索引来解决这个问题,类似于 `delete`。

#### 格式化

与删除类似,我们需要指定要格式化的文本范围,以及格式更改本身。格式存在于 `attributes` 对象中,因此一个简单的解决方案是提供一个额外的 `attributes` 对象与现有对象合并。这种合并是浅层的,以保持简单。我们还没有找到足够令人信服的用例来需要深度合并并证明增加的复杂性是合理的。

```javascript
const delta = [{
  format: {
    index: 4,
    length: 1
  },
  attributes: {
    bold: true
  }
}];
```

特殊情况是当我们想要删除格式时。我们将为此目的使用 `null`,因此 `{ bold: null }` 意味着删除粗体格式。我们本可以指定任何假值,但属性值可能有合法的用例为 `0` 或空字符串。

**注意:** 我们现在必须在应用层小心处理索引。如前所述,Deltas 不会为任何 `attributes` 的键值对,也不会为任何嵌入类型或值赋予任何固有含义。Deltas 不知道图像没有持续时间、文本没有替代文本,以及视频不能加粗。以下是一个*合法的* Delta,可能是应用其他*合法的* Deltas 的结果,由于应用程序不小心处理格式范围。

```javascript
const delta = [{
  insert: {
    image: "https://imgur.com/"
  },
  attributes: {
    duration: 600
  }
}, {
  insert: "Hello",
  attributes: {
    alt: "Funny cat photo"
  }
}, {
  insert: {
    video: "https://youtube.com/"
  },
  attributes: {
    bold: true
  }
}];
```

#### 陷阱

首先,我们应该明确,索引必须引用其在应用任何操作**之前**在文档中的位置。否则,后面的操作可能会删除之前的插入、取消之前的格式等,这将违反紧凑性。

操作还必须严格排序以满足我们的规范约束。按索引、然后长度、然后类型排序是实现此目的的一种有效方法。

如前所述,删除范围不能重叠。反对重叠格式范围的理由不那么简短,但事实证明我们也不希望格式重叠。

Delta 可能无效的原因数量正在增加。更好的格式根本不允许表达这种情况。

#### 保留

如果我们暂时退后一步,不考虑紧凑性的形式,我们可以描述一种更简单的格式来表达插入、删除和格式化:

- Delta 将具有至少与正在修改的文档一样长的操作。
- 每个操作将描述该索引处的字符发生了什么。
- 可选的插入操作可能使 Delta 比它描述的文档更长。

这需要创建一个新的操作,它只是意味着"保持此字符不变"。我们称之为 `retain`。

```javascript
// Starting with "HelloWorld",
// bold "Hello", and insert a space right after it
const change = [
  { format: true, attributes: { bold: true } },  // H
  { format: true, attributes: { bold: true } },  // e
  { format: true, attributes: { bold: true } },  // l
  { format: true, attributes: { bold: true } },  // l
  { format: true, attributes: { bold: true } },  // o
  { insert: ' ' },
  { retain: true },  // W
  { retain: true },  // o
  { retain: true },  // r
  { retain: true },  // l
  { retain: true }   // d
]
```

由于描述了每个字符,因此不再需要显式索引和长度。这使得重叠范围和乱序索引无法表达。

因此,我们可以进行简单的优化,合并相邻的相等操作,重新引入*长度*。如果最后一个操作是 `retain`,我们可以简单地删除它,因为它只是指示"对文档的其余部分不做任何操作"。

```javascript
const change = [
  { format: 5, attributes: { bold: true } }
  { insert: ' ' }
]
```

此外,你可能会注意到 `retain` 在某些方面只是 `format` 的一个特例。例如,`{ format: 1, attributes: {} }` 和 `{ retain: 1 }` 之间没有实际区别。紧凑化会删除空的 `attributes` 对象,只留下 `{ format: 1 }`,从而产生规范化冲突。因此,在我们的示例中,我们将简单地组合 `format` 和 `retain`,并保留名称 `retain`。

```javascript
const change = [
  { retain: 5, attributes: { bold: true } },
  { insert: ' ' }
]
```

我们现在有一个非常接近当前标准格式的 Delta。

#### Ops

现在我们有一个易于使用的 JSON 数组来描述富文本。这在存储和传输层非常好,但应用程序可以从更多功能中受益。我们可以通过将 Deltas 实现为一个类来添加这一点,该类可以轻松地从 JSON 初始化或导出到 JSON,然后为其提供相关方法。

在 Delta 诞生时,无法对数组进行子类化。因此,Deltas 表示为对象,具有单个属性 `ops`,该属性存储我们一直在讨论的操作数组。

```javascript
const delta = {
  ops: [{
    insert: 'Hello'
  }, {
    insert: 'World',
    attributes: { bold: true }
  }, {
    insert: {
    image: 'https://exclamation.com/mark.png'
    },
    attributes: { width: '100' }
  }]
};
```

最后,我们到达了今天存在的 [Delta 格式](/docs/delta/)。

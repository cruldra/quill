---
title: 键盘模块
---

键盘模块在特定上下文中为键盘事件启用自定义行为。Quill 使用它来绑定格式化热键并防止不良的浏览器副作用。


### 键绑定

键盘处理程序绑定到特定的键和键修饰符。`key` 是 JavaScript 事件键代码,但允许对字母数字键和一些常见键使用字符串简写。

键修饰符包括:`metaKey`、`ctrlKey`、`shiftKey` 和 `altKey`。此外,`shortKey` 是一个平台特定的修饰符,在 Mac 上等同于 `metaKey`,在 Linux 和 Windows 上等同于 `ctrlKey`。

处理程序将使用绑定到键盘实例的 `this` 调用,并传递当前选择范围。

```js
quill.keyboard.addBinding({
  key: 'b',
  shortKey: true
}, function(range, context) {
  this.quill.formatText(range, 'bold', true);
});

// addBinding 也可以使用一个参数调用,
// 形式与初始化时相同
quill.keyboard.addBinding({
  key: 'b',
  shortKey: true,
  handler: function(range, context) {

  }
});
```

如果修饰键为 `false`,则假定该修饰符未激活。你也可以传递 `null` 表示修饰符的任何值。

```js
// 只有没有修饰符的 b 会触发
quill.keyboard.addBinding({ key: 'b' }, handler);

// 只有 shift+b 会触发
quill.keyboard.addBinding({ key: ['b', 'B'], shiftKey: true }, handler);

// b 或 shift+b 都会触发
quill.keyboard.addBinding({ key: ['b', 'B'], shiftKey: null }, handler);

```

多个处理程序可以绑定到相同的键和修饰符组合。处理程序将按照它们绑定的顺序同步调用。默认情况下,处理程序停止传播到下一个处理程序,除非它明确返回 `true`。


```js
quill.keyboard.addBinding({ key: 'Tab' }, function(range) {
  // 我通常会阻止 tab 键的处理程序
  // 返回 true 以让后续处理程序被调用
  return true;
});
```

注意:由于 Quill 的默认处理程序在初始化时添加,阻止它们的唯一方法是在[配置](#configuration)中添加你的处理程序。


### 上下文

上下文使处理程序能够进一步指定仅在特定场景中调用。无论是否指定上下文,上下文对象都作为所有处理程序的第二个参数提供。

```js
// 如果用户在列表或引用块的开头按退格键,
// 删除格式而不是删除任何文本
quill.keyboard.addBinding({ key: 'Backspace' }, {
  collapsed: true,
  format: ['blockquote', 'list'],
  offset: 0
}, function(range, context) {
  if (context.format.list) {
    this.quill.format('list', false);
  } else {
    this.quill.format('blockquote', false);
  }
});
```

#### collapsed

如果为 `true`,则仅当用户的选择折叠时(即光标形式)才调用处理程序。如果为 `false`,则用户的选择必须是非零长度,例如当用户高亮显示文本时。


#### empty

如果为 `true`,则仅当用户的选择在空行上时调用,`false` 表示非空行。请注意,将 empty 设置为 true 意味着 collapsed 也为 true 且 offset 为 0&mdash;否则用户的选择将不在空行上。

```js
// 如果用户在空列表上按回车键,则删除列表
quill.keyboard.addBinding({ key: 'Enter' }, {
  empty: true,    // 意味着 collapsed: true 和 offset: 0
  format: ['list']
}, function(range, context) {
  this.quill.format('list', false);
});
```


#### format

当为数组时,如果*任何*指定的格式处于活动状态,则将调用处理程序。当为对象时,必须满足*所有*指定的格式条件。在任何一种情况下,上下文参数的 format 属性将是所有当前活动格式的对象,与 `quill.getFormat()` 返回的相同。

```js
const context = {
  format: {
    list: true,       // 必须在列表上,但可以是任何值
    script: 'super',  // 必须恰好是 'super','sub' 不够
    link: false       // 不能在任何链接中
  }
};
```


#### offset

仅当用户的选择从行的开头开始 `offset` 个字符时才会调用处理程序。请注意,这是在应用可打印键之前。这与其他上下文规范结合使用很有用。


#### prefix

必须匹配紧接在用户选择的起始位置之前的文本的正则表达式。文本不会跨格式边界匹配。提供的 `context.prefix` 值将是整个紧接在前面的文本,而不仅仅是正则表达式匹配。

```js
// 当用户输入空格时...
quill.keyboard.addBinding({ key: ' ' }, {
  collapsed: true,
  format: { list: false },  // ...在不是列表的行上
  prefix: /^-$/,            // ...在 '-' 字符之后
  offset: 1,                // ...在行的第 1 个位置,
                            // 否则如果用户在句子中间输入连字符+空格,
                            // 处理程序会触发
}, function(range, context) {
  // 空格字符被此处理程序消耗
  // 所以我们只需要删除连字符
  this.quill.deleteText(range.index - 1, 1);
  // 将项目符号格式应用于该行
  this.quill.formatLine(range.index, 1, 'list', 'bullet');
  // 恢复选择
  this.quill.setSelection(range.index - 1);

  // console.log(context.prefix) 将打印 '-'
});
```

#### suffix

与 [`prefix`](#prefix) 相同,但匹配紧接在用户选择的结束位置之后的文本。


### 配置

默认情况下,Quill 带有几个有用的键绑定,例如使用 tab 缩进列表。你可以在初始化时添加自己的绑定。

一些绑定对于防止危险的浏览器默认行为至关重要,例如回车键和退格键。你不能删除这些绑定以恢复到原生浏览器行为。但是,由于配置中指定的绑定将在 Quill 的默认绑定之前运行,因此你可以处理特殊情况并传播到 Quill 的默认行为。

使用 `quill.keyboard.addBinding` 添加绑定不会在 Quill 的默认绑定之前运行,因为默认绑定在那时已经添加了。

每个绑定配置必须包含 `key` 和 `handler` 选项,并且可以选择性地包含任何 `context` 选项。

```javascript
const bindings = {
  // 这将覆盖也名为 'tab' 的默认绑定
  tab: {
    key: 9,
    handler: function() {
      // 处理 tab
    }
  },

  // 没有名为 'custom' 的默认绑定
  // 所以这将被添加而不会覆盖任何内容
  custom: {
    key: ['b', 'B'],
    shiftKey: true,
    handler: function(range, context) {
      // 处理 shift+b
    }
  },

  list: {
    key: 'Backspace',
    format: ['list'],
    handler: function(range, context) {
      if (context.offset === 0) {
        // 当在列表的第一个字符上按退格键时,
        // 删除列表
        this.quill.format('list', false, Quill.sources.USER);
      } else {
        // 否则传播到 Quill 的默认行为
        return true;
      }
    }
  }
};

const quill = new Quill('#editor', {
  modules: {
    keyboard: {
      bindings: bindings
    }
  }
});
```


### 性能

与 DOM 事件一样,Quill 键绑定在每次匹配时都是阻塞调用,因此对于非常常见的键绑定使用非常昂贵的处理程序是一个坏主意。应用与附加到常见阻塞 DOM 事件(如 `scroll` 或 `mousemove`)时相同的性能最佳实践。

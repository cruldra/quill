---
title: 使用 Parchment 克隆 Medium
---

要提供一致的编辑体验,你需要一致的数据和可预测的行为。不幸的是,DOM 缺少这两者。现代编辑器的解决方案是维护自己的文档模型来表示其内容。[Parchment](https://github.com/quilljs/parchment/) 就是 Quill 的解决方案。它在自己的代码库中组织,具有自己的 API 层。通过 Parchment,你可以自定义 Quill 识别的内容和格式,或添加全新的内容和格式。

在本指南中,我们将使用 Parchment 和 Quill 提供的构建块来复制 Medium 上的编辑器。我们将从 Quill 的基本框架开始,没有任何主题、额外的模块或格式。在这个基本级别,Quill 只理解纯文本。但在本指南结束时,链接、视频甚至推文都将被理解。

## 基础工作

让我们从不使用 Quill 开始,只使用一个 textarea 和按钮,连接到一个虚拟事件监听器。为了方便起见,我们将在本指南中使用 jQuery,但 Quill 和 Parchment 都不依赖于此。我们还将添加一些基本样式,借助 [Google Fonts](https://fonts.google.com/) 和 [Font Awesome](https://fontawesome.io/)。这些都与 Quill 或 Parchment 无关,所以我们会快速进行。

<Sandpack
  externalResources={scope.externalResources}
  defaultShowPreview
  showFileTree
  files={{
    'index.html': `
${scope.basicHTML}
<textarea id="editor">Tell your story...</textarea>

<script type="module" src="/index.js"></script>
    `,
    'styles.css': `
#editor {
  display: block;
  font-family: 'Open Sans', Helvetica, sans-serif;
  font-size: 1.2em;
  height: 180px;
  margin: 0 auto;
  width: 450px;
}

#tooltip-controls, #sidebar-controls {
  text-align: center;
}

button {
  background: transparent;
  border: none;
  cursor: pointer;
  display: inline-block;
  font-size: 18px;
  padding: 0;
  height: 32px;
  width: 32px;
  text-align: center;
}
button:active, button:focus {
  outline: none;
}
    `,
    'index.js': `
document.querySelectorAll('button').forEach((button) => {
  button.addEventListener('click', () => {
    alert('Click!');
  });
});
    `
  }}
/>

## 添加 Quill 核心

接下来,我们将用 Quill 核心替换 textarea,没有主题、格式和额外的模块。在你输入编辑器时打开开发者控制台检查演示。你可以看到 Parchment 文档的基本构建块在工作。

<Sandpack
  externalResources={scope.externalResources}
  showFileTree
  defaultShowPreview
  files={{
    'index.html': scope.html,
    'styles.css': `
${scope.basicCSS}
    `,
    'index.js': `
document.querySelectorAll('button').forEach((button) => {
  button.addEventListener('click', () => {
    alert('Click!');
  });
});

const quill = new Quill('#editor');
    `
  }}
/>


与 DOM 一样,Parchment 文档是一棵树。它的节点称为 Blot,是对 DOM 节点的抽象。已经为我们定义了一些 blot:Scroll、Block、Inline、Text 和 Break。当你输入时,Text blot 与相应的 DOM Text 节点同步;通过创建新的 Block blot 来处理回车。在 Parchment 中,可以有子节点的 Blot 必须至少有一个子节点,因此空 Block 用 Break blot 填充。这使得处理叶子节点简单且可预测。所有这些都组织在根 Scroll blot 下。

此时你无法通过输入观察到 Inline blot,因为它不会为文档贡献有意义的结构或格式。有效的 Quill 文档必须是规范的和紧凑的。只有一个有效的 DOM 树可以表示给定的文档,并且该 DOM 树包含最少数量的节点。

由于 `<p><span>Text</span></p>` 和 `<p>Text</p>` 表示相同的内容,前者是无效的,解包 `<span>` 是 Quill 优化过程的一部分。同样,一旦我们添加格式,`<p><em>Te</em><em>st</em></p>` 和 `<p><em><em>Test</em></em></p>` 也是无效的,因为它们不是最紧凑的表示。

由于这些约束,**Quill 无法支持任意 DOM 树和 HTML 更改**。但正如我们将看到的,这种结构提供的一致性和可预测性使我们能够轻松构建丰富的编辑体验。

## 基本格式化

我们之前提到 Inline 不贡献格式化。这是例外,而不是规则,是为基本 Inline 类制定的。基本 Block blot 对块级元素的工作方式相同。

要实现粗体和斜体,我们只需要从 Inline 继承,设置 `blotName` 和 `tagName`,并将其注册到 Quill。有关继承和静态方法和变量的签名的完整参考,请查看 [Parchment](https://github.com/quilljs/parchment/)。

```js
const Inline = Quill.import('blots/inline');

class BoldBlot extends Inline {
  static blotName = 'bold';
  static tagName = 'strong';
}

class ItalicBlot extends Inline {
  static blotName = 'italic';
  static tagName = 'em';
}

Quill.register(BoldBlot);
Quill.register(ItalicBlot);
```

我们在这里遵循 Medium 的示例使用 `strong` 和 `em` 标签,但你也可以使用 `b` 和 `i` 标签。blot 的名称将被 Quill 用作格式的名称。通过注册我们的 blot,我们现在可以在新格式上使用 Quill 的完整 API:

```js
Quill.register(BoldBlot);
Quill.register(ItalicBlot);

const quill = new Quill('#editor');

quill.insertText(0, 'Test', { bold: true });
quill.formatText(0, 4, 'italic', true);
// 如果我们将斜体 blot 命名为 "myitalic",我们会调用
// quill.formatText(0, 4, 'myitalic', true);
```

让我们摆脱虚拟按钮处理程序,并将粗体和斜体按钮连接到 Quill 的 [`format()`](/docs/api/#format)。为了简单起见,我们将硬编码 `true` 以始终添加格式。在你的应用程序中,你可以使用 [`getFormat()`](/docs/api/#getformat) 来检索任意范围内的当前格式,以决定是添加还是删除格式。[工具栏](/docs/modules/toolbar/)模块为 Quill 实现了这一点,我们不会在这里重新实现它。

打开你的开发者控制台,在你的新粗体和斜体格式上尝试 Quill 的 [API](/docs/api)!确保将上下文设置为正确的 CodePen iframe,以便能够访问演示中的 `quill` 变量。

<Sandpack
  externalResources={scope.externalResources}
  showFileTree
  defaultShowPreview
  activeFile="index.js"
  files={{
    'index.html': scope.html,
    'styles.css': `
${scope.basicCSS}
    `,
    'formats/boldBlot.js': scope.boldBlot,
    'formats/italicBlot.js': scope.italicBlot,
    'index.js': `
import './formats/boldBlot.js';
import './formats/italicBlot.js';

const onClick = (selector, callback) => {
  document.querySelector(selector).addEventListener('click', callback);
};

onClick('#bold-button', () => {
  quill.format('bold', true);
});

onClick('#italic-button', () => {
  quill.format('italic', true);
});

const quill = new Quill('#editor');
    `
  }}
/>

请注意,如果你对某些文本同时应用粗体和斜体,无论你以什么顺序执行此操作,Quill 都会以一致的顺序将 `<strong>` 标签包装在 `<em>` 标签外部。

## 链接

链接稍微复杂一些,因为我们需要的不仅仅是布尔值来存储链接 url。这以两种方式影响我们的 Link blot:创建和格式检索。我们将 url 表示为字符串值,但我们可以轻松地以其他方式表示,例如具有 url 键的对象,允许设置其他键/值对并定义链接。我们稍后将使用[图像](#images)演示这一点。

```js
class LinkBlot extends Inline {
  static blotName = 'link';
  static tagName = 'a';

  static create(value) {
    const node = super.create();
    // 如果需要,清理 url 值
    node.setAttribute('href', value);
    // 可以设置其他非格式相关的属性
    // 这些对 Parchment 不可见,因此必须是静态的
    node.setAttribute('target', '_blank');
    return node;
  }

  static formats(node) {
    // 我们只会使用已经
    // 确定为 Link blot 的节点调用,所以我们
    // 不需要自己检查
    return node.getAttribute('href');
  }
}

Quill.register(LinkBlot);
```

现在我们可以将链接按钮连接到一个花哨的 `prompt`,再次为了保持简单,然后传递给 Quill 的 `format()`。

<Sandpack
  externalResources={scope.externalResources}
  showFileTree
  defaultShowPreview
  activeFile="formats/linkBlot.js"
  files={{
    'index.html': scope.html,
    'styles.css': `
${scope.basicCSS}
    `,
    'formats/boldBlot.js': scope.boldBlot,
    'formats/italicBlot.js': scope.italicBlot,
    'formats/linkBlot.js': scope.linkBlot,
    'index.js': `
import './formats/boldBlot.js';
import './formats/italicBlot.js';
import './formats/linkBlot.js';

const onClick = (selector, callback) => {
  document.querySelector(selector).addEventListener('click', callback);
};

onClick('#bold-button', () => {
  quill.format('bold', true);
});

onClick('#italic-button', () => {
  quill.format('italic', true);
});

onClick('#link-button', () => {
  const value = prompt('Enter link URL');
  quill.format('link', value);
});

const quill = new Quill('#editor');
    `
  }}
/>

## 引用块和标题

引用块的实现方式与 Bold blot 相同,只是我们将从 Block(基本块级 Blot)继承。虽然 Inline blot 可以嵌套,但 Block blot 不能。Block blot 在应用于相同文本范围时会相互替换,而不是包装。

```js
const Block = Quill.import('blots/block');

class BlockquoteBlot extends Block {
  static blotName = 'blockquote';
  static tagName = 'blockquote';
}
```

标题的实现方式完全相同,只有一个区别:它可以由多个 DOM 元素表示。默认情况下,格式的值变为 tagName,而不仅仅是 `true`。我们可以通过扩展 `formats()` 来自定义这一点,类似于我们为[链接](#links)所做的。

```js
class HeaderBlot extends Block {
  static blotName = 'header';
  // Medium 只支持两种标题大小,所以我们只演示两种,
  // 但我们可以轻松地将更多标签添加到此数组中
  static tagName = ['H1', 'H2'];

  static formats(node) {
    return HeaderBlot.tagName.indexOf(node.tagName) + 1;
  }
}
```

让我们将这些新 blot 连接到它们各自的按钮,并为 `<blockquote>` 标签添加一些 CSS。

<Sandpack
  externalResources={scope.externalResources}
  showFileTree
  defaultShowPreview
  activeFile="formats/blockquoteBlot.js"
  files={{
    'index.html': scope.html,
    'styles.css': `
${scope.cssWithBlockquoteAndHeader}
    `,
    'formats/boldBlot.js': scope.boldBlot,
    'formats/italicBlot.js': scope.italicBlot,
    'formats/linkBlot.js': scope.linkBlot,
    'formats/blockquoteBlot.js': scope.blockquoteBlot,
    'formats/headerBlot.js': scope.headerBlot,
    'index.js': `
import './formats/boldBlot.js';
import './formats/italicBlot.js';
import './formats/linkBlot.js';
import './formats/blockquoteBlot.js';
import './formats/headerBlot.js';

const onClick = (selector, callback) => {
  document.querySelector(selector).addEventListener('click', callback);
};

onClick('#bold-button', () => {
  quill.format('bold', true);
});

onClick('#italic-button', () => {
  quill.format('italic', true);
});

onClick('#link-button', () => {
  const value = prompt('Enter link URL');
  quill.format('link', value);
});

onClick('#blockquote-button', () => {
  quill.format('blockquote', true);
});

onClick('#header-1-button', () => {
  quill.format('header', 1);
});

onClick('#header-2-button', () => {
  quill.format('header', 2);
});

const quill = new Quill('#editor');
    `
  }}
/>

尝试将一些文本设置为 H1,然后在控制台中运行 `quill.getContents()`。你将看到我们的自定义静态 `formats()` 函数在工作。确保将上下文设置为正确的 CodePen iframe,以便能够访问演示中的 `quill` 变量。

## 分隔符

现在让我们实现第一个叶子 Blot。虽然我们之前的 Blot 示例贡献格式化并实现 `format()`,但叶子 Blot 贡献内容并实现 `value()`。叶子 Blot 可以是 Text 或 Embed Blot,因此我们的分隔符将是 Embed。一旦创建,Embed Blot 的值是不可变的,需要删除和重新插入才能更改该位置的内容。

我们的方法与之前类似,只是我们从 BlockEmbed 继承。Embed 也存在于 `blots/embed` 下,但用于内联级 blot。我们希望为分隔符使用块级实现。

```js
const BlockEmbed = Quill.import('blots/block/embed');

class DividerBlot extends BlockEmbed {
  static blotName = 'divider';
  static tagName = 'hr';
}
```

我们的点击处理程序调用 [`insertEmbed()`](/docs/api/#insertembed),它不像 [`format()`](/docs/api/#format) 那样方便地为我们确定、保存和恢复用户选择,因此我们必须做更多的工作来自己保留选择。此外,当我们尝试在 Block 中间插入 BlockEmbed 时,Quill 会为我们拆分 Block。为了使这种行为更清楚,我们将通过在插入分隔符之前插入换行符来显式拆分块。查看 CodePen 中的 Babel 选项卡以获取详细信息。

<Sandpack
  externalResources={scope.externalResources}
  showFileTree
  defaultShowPreview
  activeFile="formats/dividerBlot.js"
  files={{
    'index.html': scope.html,
    'styles.css': scope.cssWithBlockquoteAndHeader,
    'formats/boldBlot.js': scope.boldBlot,
    'formats/italicBlot.js': scope.italicBlot,
    'formats/linkBlot.js': scope.linkBlot,
    'formats/blockquoteBlot.js': scope.blockquoteBlot,
    'formats/headerBlot.js': scope.headerBlot,
    'formats/dividerBlot.js': scope.dividerBlot,
    'index.js': `
import './formats/boldBlot.js';
import './formats/italicBlot.js';
import './formats/linkBlot.js';
import './formats/blockquoteBlot.js';
import './formats/headerBlot.js';
import './formats/dividerBlot.js';

const onClick = (selector, callback) => {
  document.querySelector(selector).addEventListener('click', callback);
};

onClick('#bold-button', () => {
  quill.format('bold', true);
});

onClick('#italic-button', () => {
  quill.format('italic', true);
});

onClick('#link-button', () => {
  const value = prompt('Enter link URL');
  quill.format('link', value);
});

onClick('#blockquote-button', () => {
  quill.format('blockquote', true);
});

onClick('#header-1-button', () => {
  quill.format('header', 1);
});

onClick('#header-2-button', () => {
  quill.format('header', 2);
});

onClick('#divider-button', () => {
  const range = quill.getSelection(true);
  quill.insertText(range.index, '\\n', Quill.sources.USER);
  quill.insertEmbed(range.index + 1, 'divider', true, Quill.sources.USER);
  quill.setSelection(range.index + 2, Quill.sources.SILENT);
});

const quill = new Quill('#editor');
    `
  }}
/>

## 图像

可以使用我们在构建[链接](#links)和[分隔符](#divider) blot 时学到的知识添加图像。我们将使用对象作为值来展示如何支持这一点。我们插入图像的按钮处理程序将使用静态值,因此我们不会被与 [Parchment](https://github.com/quilljs/parchment/) 无关的工具提示 UI 代码分散注意力,这是本指南的重点。

```js
const BlockEmbed = Quill.import('blots/block/embed');

class ImageBlot extends BlockEmbed {
  static blotName = 'image';
  static tagName = 'img';

  static create(value) {
    const node = super.create();
    node.setAttribute('alt', value.alt);
    node.setAttribute('src', value.url);
    return node;
  }

  static value(node) {
    return {
      alt: node.getAttribute('alt'),
      url: node.getAttribute('src')
    };
  }
}
```

<Sandpack
  externalResources={scope.externalResources}
  showFileTree
  defaultShowPreview
  activeFile="formats/imageBlot.js"
  files={{
    'index.html': scope.html,
    'styles.css': scope.cssWithBlockquoteAndHeader,
    'formats/boldBlot.js': scope.boldBlot,
    'formats/italicBlot.js': scope.italicBlot,
    'formats/linkBlot.js': scope.linkBlot,
    'formats/blockquoteBlot.js': scope.blockquoteBlot,
    'formats/headerBlot.js': scope.headerBlot,
    'formats/dividerBlot.js': scope.dividerBlot,
    'formats/imageBlot.js': scope.imageBlot,
    'index.js': `
import './formats/boldBlot.js';
import './formats/italicBlot.js';
import './formats/linkBlot.js';
import './formats/blockquoteBlot.js';
import './formats/headerBlot.js';
import './formats/dividerBlot.js';
import './formats/imageBlot.js';

const onClick = (selector, callback) => {
  document.querySelector(selector).addEventListener('click', callback);
};

onClick('#bold-button', () => {
  quill.format('bold', true);
});

onClick('#italic-button', () => {
  quill.format('italic', true);
});

onClick('#link-button', () => {
  const value = prompt('Enter link URL');
  quill.format('link', value);
});

onClick('#blockquote-button', () => {
  quill.format('blockquote', true);
});

onClick('#header-1-button', () => {
  quill.format('header', 1);
});

onClick('#header-2-button', () => {
  quill.format('header', 2);
});

onClick('#divider-button', () => {
  const range = quill.getSelection(true);
  quill.insertText(range.index, '\\n', Quill.sources.USER);
  quill.insertEmbed(range.index + 1, 'divider', true, Quill.sources.USER);
  quill.setSelection(range.index + 2, Quill.sources.SILENT);
});

onClick('#image-button', () => {
  const range = quill.getSelection(true);
  quill.insertText(range.index, '\\n', Quill.sources.USER);
  quill.insertEmbed(range.index + 1, 'image', {
    alt: 'Quill Cloud',
    url: 'https://quilljs.com/0.20/assets/images/cloud.png'
  }, Quill.sources.USER);
  quill.setSelection(range.index + 2, Quill.sources.SILENT);
});

const quill = new Quill('#editor');
    `
  }}
/>


## 视频

我们将以与[图像](#images)类似的方式实现视频。我们可以使用 HTML5 `<video>` 标签,但我们无法以这种方式播放 YouTube 视频,由于这可能是更常见和相关的用例,我们将使用 `<iframe>` 来支持这一点。我们不必在这里这样做,但如果你希望多个 Blot 使用相同的标签,你可以在 `tagName` 之外使用 `className`,在下一个 [Tweet](#tweet) 示例中演示。

此外,我们将添加对宽度和高度的支持,作为未注册的格式。特定于 Embed 的格式不必单独注册,只要与注册的格式没有命名空间冲突。这是有效的,因为 Blot 只是将未知格式传递给其子节点,最终到达叶子节点。这也允许不同的 Embed 以不同的方式处理未注册的格式。例如,我们之前的[图像](#images) embed 可以识别并处理 `width` 格式,与我们的视频在这里的处理方式不同。

```js
class VideoBlot extends BlockEmbed {
  static blotName = 'video';
  static tagName = 'iframe';

  static create(url) {
    const node = super.create();
    node.setAttribute('src', url);
    // 使用静态值设置非格式相关的属性
    node.setAttribute('frameborder', '0');
    node.setAttribute('allowfullscreen', true);

    return node;
  }

  static formats(node) {
    // 我们仍然需要报告未注册的嵌入格式
    const format = {};
    if (node.hasAttribute('height')) {
      format.height = node.getAttribute('height');
    }
    if (node.hasAttribute('width')) {
      format.width = node.getAttribute('width');
    }
    return format;
  }

  static value(node) {
    return node.getAttribute('src');
  }

  format(name, value) {
    // 处理未注册的嵌入格式
    if (name === 'height' || name === 'width') {
      if (value) {
        this.domNode.setAttribute(name, value);
      } else {
        this.domNode.removeAttribute(name, value);
      }
    } else {
      super.format(name, value);
    }
  }
}
```

请注意,如果你打开控制台并调用 [`getContents`](/docs/api/#getcontents),Quill 将报告视频为:

```js
{
  ops: [{
    insert: {
      video: 'https://www.youtube.com/embed/QHH3iSeDBLo?showinfo=0'
    },
    attributes: {
      height: '170',
      width: '400'
    }
  }]
}
```

<Sandpack
  externalResources={scope.externalResources}
  showFileTree
  defaultShowPreview
  activeFile="formats/videoBlot.js"
  files={{
    'index.html': scope.html,
    'styles.css': scope.cssWithBlockquoteAndHeader,
    'formats/boldBlot.js': scope.boldBlot,
    'formats/italicBlot.js': scope.italicBlot,
    'formats/linkBlot.js': scope.linkBlot,
    'formats/blockquoteBlot.js': scope.blockquoteBlot,
    'formats/headerBlot.js': scope.headerBlot,
    'formats/dividerBlot.js': scope.dividerBlot,
    'formats/imageBlot.js': scope.imageBlot,
    'formats/videoBlot.js': scope.videoBlot,
    'index.js': `
import './formats/boldBlot.js';
import './formats/italicBlot.js';
import './formats/linkBlot.js';
import './formats/blockquoteBlot.js';
import './formats/headerBlot.js';
import './formats/dividerBlot.js';
import './formats/imageBlot.js';
import './formats/videoBlot.js';

const onClick = (selector, callback) => {
  document.querySelector(selector).addEventListener('click', callback);
};

onClick('#bold-button', () => {
  quill.format('bold', true);
});

onClick('#italic-button', () => {
  quill.format('italic', true);
});

onClick('#link-button', () => {
  const value = prompt('Enter link URL');
  quill.format('link', value);
});

onClick('#blockquote-button', () => {
  quill.format('blockquote', true);
});

onClick('#header-1-button', () => {
  quill.format('header', 1);
});

onClick('#header-2-button', () => {
  quill.format('header', 2);
});

onClick('#divider-button', () => {
  const range = quill.getSelection(true);
  quill.insertText(range.index, '\\n', Quill.sources.USER);
  quill.insertEmbed(range.index + 1, 'divider', true, Quill.sources.USER);
  quill.setSelection(range.index + 2, Quill.sources.SILENT);
});

onClick('#image-button', () => {
  const range = quill.getSelection(true);
  quill.insertText(range.index, '\\n', Quill.sources.USER);
  quill.insertEmbed(range.index + 1, 'image', {
    alt: 'Quill Cloud',
    url: 'https://quilljs.com/0.20/assets/images/cloud.png'
  }, Quill.sources.USER);
  quill.setSelection(range.index + 2, Quill.sources.SILENT);
});

onClick('#video-button', () => {
  let range = quill.getSelection(true);
  quill.insertText(range.index, '\\n', Quill.sources.USER);
  let url = 'https://www.youtube.com/embed/QHH3iSeDBLo?showinfo=0';
  quill.insertEmbed(range.index + 1, 'video', url, Quill.sources.USER);
  quill.formatText(range.index + 1, 1, { height: '170', width: '400' });
  quill.setSelection(range.index + 2, Quill.sources.SILENT);
});

const quill = new Quill('#editor');
    `
  }}
/>

## 推文

Medium 支持许多嵌入类型,但我们将在本指南中只关注推文。Tweet blot 的实现几乎与[图像](#images)完全相同。我们利用了 Embed blot 不必对应于 void 节点的事实。它可以是任意节点,Quill 会将其视为 void 节点,不会遍历其子节点或后代。这允许我们使用 `<div>` 和原生 Twitter JavaScript 库在我们指定的 `<div>` 容器内执行它想要的操作。

由于我们的根 Scroll Blot 也使用 `<div>`,我们还指定了 `className` 来消除歧义。请注意,Inline blot 默认使用 `<span>`,Block Blot 默认使用 `<p>`,因此如果你想为自定义 Blot 使用这些标签,则必须在 `tagName` 之外指定 `className`。

我们使用 Tweet id 作为定义 Blot 的值。同样,我们的点击处理程序使用静态值以避免被无关的 UI 代码分散注意力。

```js
class TweetBlot extends BlockEmbed {
  static blotName = 'tweet';
  static tagName = 'div';
  static className = 'tweet';

  static create(id) {
    const node = super.create();
    node.dataset.id = id;
    // 允许 twitter 库修改我们的内容
    twttr.widgets.createTweet(id, node);
    return node;
  }

  static value(domNode) {
    return domNode.dataset.id;
  }
}
```

<Sandpack
  externalResources={scope.externalResources}
  showFileTree
  defaultShowPreview
  activeFile="formats/tweetBlot.js"
  files={{
    'index.html': scope.html,
    'styles.css': scope.cssWithBlockquoteAndHeader,
    'formats/boldBlot.js': scope.boldBlot,
    'formats/italicBlot.js': scope.italicBlot,
    'formats/linkBlot.js': scope.linkBlot,
    'formats/blockquoteBlot.js': scope.blockquoteBlot,
    'formats/headerBlot.js': scope.headerBlot,
    'formats/dividerBlot.js': scope.dividerBlot,
    'formats/imageBlot.js': scope.imageBlot,
    'formats/videoBlot.js': scope.videoBlot,
    'formats/tweetBlot.js': scope.tweetBlot,
    'index.js': `
import './formats/boldBlot.js';
import './formats/italicBlot.js';
import './formats/linkBlot.js';
import './formats/blockquoteBlot.js';
import './formats/headerBlot.js';
import './formats/dividerBlot.js';
import './formats/imageBlot.js';
import './formats/videoBlot.js';
import './formats/tweetBlot.js';

const onClick = (selector, callback) => {
  document.querySelector(selector).addEventListener('click', callback);
};

onClick('#bold-button', () => {
  quill.format('bold', true);
});

onClick('#italic-button', () => {
  quill.format('italic', true);
});

onClick('#link-button', () => {
  const value = prompt('Enter link URL');
  quill.format('link', value);
});

onClick('#blockquote-button', () => {
  quill.format('blockquote', true);
});

onClick('#header-1-button', () => {
  quill.format('header', 1);
});

onClick('#header-2-button', () => {
  quill.format('header', 2);
});

onClick('#divider-button', () => {
  const range = quill.getSelection(true);
  quill.insertText(range.index, '\\n', Quill.sources.USER);
  quill.insertEmbed(range.index + 1, 'divider', true, Quill.sources.USER);
  quill.setSelection(range.index + 2, Quill.sources.SILENT);
});

onClick('#image-button', () => {
  const range = quill.getSelection(true);
  quill.insertText(range.index, '\\n', Quill.sources.USER);
  quill.insertEmbed(range.index + 1, 'image', {
    alt: 'Quill Cloud',
    url: 'https://quilljs.com/0.20/assets/images/cloud.png'
  }, Quill.sources.USER);
  quill.setSelection(range.index + 2, Quill.sources.SILENT);
});

onClick('#video-button', () => {
  let range = quill.getSelection(true);
  quill.insertText(range.index, '\\n', Quill.sources.USER);
  let url = 'https://www.youtube.com/embed/QHH3iSeDBLo?showinfo=0';
  quill.insertEmbed(range.index + 1, 'video', url, Quill.sources.USER);
  quill.formatText(range.index + 1, 1, { height: '170', width: '400' });
  quill.setSelection(range.index + 2, Quill.sources.SILENT);
});

onClick('#tweet-button', () => {
  const range = quill.getSelection(true);
  const id = '464454167226904576';
  quill.insertText(range.index, '\\n', Quill.sources.USER);
  quill.insertEmbed(range.index + 1, 'tweet', id, Quill.sources.USER);
  quill.setSelection(range.index + 2, Quill.sources.SILENT);
});

const quill = new Quill('#editor');
    `
  }}
/>


{/*

### Final Polish

We began with just a bunch of buttons and a Quill core that just understands plaintext. With Parchment, we are able to add bold, italic, links, blockquotes, headers, section dividers, images, videos, and even Tweets. All of this comes while maintaining a predictable and consistent document, allowing us to use Quill's powerful [APIs](/docs/api) with these new formats and content.

Let's add some final polish to finish off our demo. It won't compare to Medium's UI, but we'll try to get close.

<CodePen hash="qNJrYB" defaultTab="result" />

*/}